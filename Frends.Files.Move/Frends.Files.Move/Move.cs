using Frends.Files.Move.Definitions;
using Microsoft.Extensions.FileSystemGlobbing;
using Microsoft.Extensions.FileSystemGlobbing.Abstractions;
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Linq;
using System.ComponentModel;
using SimpleImpersonation;
using System.Security.Principal;
using Microsoft.Win32.SafeHandles;
using System.Threading;
using System.Threading.Tasks;
using System.Text.RegularExpressions;

namespace Frends.Files.Move;
///<summary>
/// Files task.
/// </summary>
public class Files
{
    /// <summary>
    /// Move files.
    /// [Documentation](https://tasks.frends.com/tasks/frends-tasks/Frends.Files.Move)
    /// </summary>
    /// <param name="input">Input parameters</param>
    /// <param name="options">Options parameters</param>
    /// <param name="cancellationToken">Token to stop task. This is generated by Frends.</param>
    /// <returns>Result object { List&lt;FileItem&gt; }</returns>
    public static async Task<Result> Move([PropertyTab] Input input, [PropertyTab] Options options, CancellationToken cancellationToken)
    {
        var result = await ExecuteMoveAsync(input, options, cancellationToken);
        return new Result(result);
    }

    private static async Task<List<FileItem>> ExecuteMoveAsync(Input input, Options options, CancellationToken cancellationToken)
    {
        bool needsImpersonationForDiscovery = options.RemotePath == RemotePathType.Source;

        PatternMatchingResult results;

        if (needsImpersonationForDiscovery)
        {
            // Find files with impersonation (remote source)
            results = await FindMatchingFilesWithImpersonation(input.Directory, input.Pattern, options);
        }
        else
        {
            // Find files with local credentials (local source)
            results = FindMatchingFiles(input.Directory, input.Pattern);
        }

        var fileTransferEntries = GetFileTransferEntries(results.Files, input.Directory, input.TargetDirectory, options.PreserveDirectoryStructure);

        if (options.IfTargetFileExists == FileExistsAction.Throw)
            AssertNoTargetFileConflicts(fileTransferEntries.Values);

        if (options.CreateTargetDirectories)
        {
            bool needsImpersonationForTargetDir = options.RemotePath == RemotePathType.Target;

            if (needsImpersonationForTargetDir && !string.IsNullOrEmpty(options.UserName))
            {
                await ExecuteWithImpersonation(options, async () =>
                {
                    Directory.CreateDirectory(input.TargetDirectory);
                    await Task.CompletedTask;
                });
            }
            else
            {
                Directory.CreateDirectory(input.TargetDirectory);
            }
        }

        var fileResults = new List<FileItem>();
        try
        {
            foreach (var entry in fileTransferEntries)
            {
                cancellationToken.ThrowIfCancellationRequested();

                var sourceFilePath = entry.Key;
                var targetFilePath = entry.Value;

                if (options.CreateTargetDirectories)
                {
                    var targetDir = Path.GetDirectoryName(targetFilePath);
                    bool needsImpersonationForFileDir = options.RemotePath == RemotePathType.Target;

                    if (needsImpersonationForFileDir && !string.IsNullOrEmpty(options.UserName))
                    {
                        await ExecuteWithImpersonation(options, async () =>
                        {
                            Directory.CreateDirectory(targetDir);
                            await Task.CompletedTask;
                        });
                    }
                    else
                    {
                        Directory.CreateDirectory(targetDir);
                    }
                }

                switch (options.IfTargetFileExists)
                {
                    case FileExistsAction.Rename:
                        targetFilePath = GetNonConflictingDestinationFilePath(sourceFilePath, targetFilePath);
                        break;
                    case FileExistsAction.Overwrite:
                        bool needsImpersonationForDelete = options.RemotePath == RemotePathType.Target;

                        if (File.Exists(targetFilePath))
                        {
                            if (needsImpersonationForDelete && !string.IsNullOrEmpty(options.UserName))
                            {
                                await ExecuteWithImpersonation(options, async () =>
                                {
                                    File.Delete(targetFilePath);
                                    await Task.CompletedTask;
                                });
                            }
                            else
                            {
                                File.Delete(targetFilePath);
                            }
                        }
                        break;
                    case FileExistsAction.Throw:

                        bool needsImpersonationForCheck = options.RemotePath == RemotePathType.Target;

                        bool fileExists;
                        if (needsImpersonationForCheck && !string.IsNullOrEmpty(options.UserName))
                        {
                            fileExists = false;
                            await ExecuteWithImpersonation(options, async () =>
                            {
                                fileExists = File.Exists(targetFilePath);
                                await Task.CompletedTask;
                            });
                        }
                        else
                        {
                            fileExists = File.Exists(targetFilePath);
                        }

                        if (fileExists)
                            throw new IOException($"File '{targetFilePath}' already exists. No files moved.");
                        break;
                }

                // Copy according to remote mode
                await ExecuteCopyAsync(sourceFilePath, targetFilePath, options, cancellationToken);

                fileResults.Add(new FileItem(sourceFilePath, targetFilePath));
            }
        }
        catch (Exception)
        {
            // Clean up target files - also needs proper credentials
            await DeleteExistingFilesWithCredentials(fileResults.Select(x => x.TargetPath), options, isTarget: true);
            throw;
        }

        // Delete source files - also needs proper credentials  
        await DeleteExistingFilesWithCredentials(fileResults.Select(x => x.SourcePath), options, isTarget: false);
        return fileResults;
    }

    private static async Task<PatternMatchingResult> FindMatchingFilesWithImpersonation(string directoryPath, string pattern, Options options)
    {
        PatternMatchingResult results = null;

        await ExecuteWithImpersonation(options, async () =>
        {
            results = FindMatchingFiles(directoryPath, pattern);
            await Task.CompletedTask;
        });

        return results;
    }

    private static async Task DeleteExistingFilesWithCredentials(IEnumerable<string> filePaths, Options options, bool isTarget)
    {
        bool needsImpersonation = (isTarget && options.RemotePath == RemotePathType.Target) ||
                                 (!isTarget && (options.RemotePath == RemotePathType.Source));

        if (needsImpersonation && !string.IsNullOrEmpty(options.UserName))
        {
            await ExecuteWithImpersonation(options, async () =>
            {
                DeleteExistingFiles(filePaths);
                await Task.CompletedTask;
            });
        }
        else
        {
            DeleteExistingFiles(filePaths);
        }
    }


    private static async Task CopyFileAsync(string source, string destination, CancellationToken cancellationToken)
    {
        using FileStream sourceStream = File.Open(source, FileMode.Open);
        using FileStream destinationStream = File.Open(destination, FileMode.CreateNew);

        await sourceStream.CopyToAsync(destinationStream, 81920, cancellationToken).ConfigureAwait(false);
    }

    internal static Tuple<string, string> GetDomainAndUsername(string username)
    {
        var domainAndUserName = username.Split('\\');
        if (domainAndUserName.Length != 2)
            throw new ArgumentException($@"UserName field must be of format domain\username was: {username}");
        return new Tuple<string, string>(domainAndUserName[0], domainAndUserName[1]);
    }

    internal static PatternMatchingResult FindMatchingFiles(string directoryPath, string pattern)
    {
        // Check the user can access the folder
        // This will return false if the path does not exist or you do not have read permissions.
        if (!Directory.Exists(directoryPath))
        {
            try
            {
                var entries = Directory.GetFileSystemEntries(directoryPath);
                Console.WriteLine($"[DEBUG] GetFileSystemEntries succeeded, found {entries.Length} items");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[DEBUG] GetFileSystemEntries failed: {ex.Message}");
            }

            throw new DirectoryNotFoundException($"Directory does not exist or you do not have read access. Tried to access directory '{directoryPath}'");
        }

        if (pattern.StartsWith("<regex>"))
        {
            string regexPattern = pattern.Substring(7);

            var matchingFiles = Directory.GetFiles(directoryPath, "*", SearchOption.AllDirectories)
                .Where(file => Regex.IsMatch(Path.GetFileName(file), regexPattern))
                .Select(file => new FilePatternMatch(Path.GetFileName(file), Path.GetFileName(file)))
                .ToList();

            return new PatternMatchingResult(matchingFiles);
        }
        else
        {

            var matcher = new Matcher();
            matcher.AddInclude(pattern);
            var results = matcher.Execute(new DirectoryInfoWrapper(new DirectoryInfo(directoryPath)));
            return results;
        }
    }

    private static Dictionary<string, string> GetFileTransferEntries(IEnumerable<FilePatternMatch> fileMatches, string sourceDirectory, string targetDirectory, bool preserveDirectoryStructure)
    {
        return fileMatches
            .ToDictionary(
                f => Path.Combine(sourceDirectory, f.Path),
                f => preserveDirectoryStructure
                 ? Path.GetFullPath(Path.Combine(targetDirectory, f.Path))
                 : Path.GetFullPath(Path.Combine(targetDirectory, Path.GetFileName(f.Path))));
    }

    private static void AssertNoTargetFileConflicts(IEnumerable<string> filePaths)
    {
        // check the target file list to see there should not be conflicts before doing anything
        var duplicateTargetPaths = GetDuplicateValues(filePaths);
        if (duplicateTargetPaths.Any())
            throw new IOException($"Multiple files written to {string.Join(", ", duplicateTargetPaths)}. The files would get overwritten. No files moved.");

        foreach (var targetFilePath in filePaths)
            if (File.Exists(targetFilePath))
                throw new IOException($"File '{targetFilePath}' already exists. No files moved.");
    }

    private static IList<string> GetDuplicateValues(IEnumerable<string> values)
    {
        return values.GroupBy(v => v).Where(x => x.Count() > 1).Select(k => k.Key).ToList();
    }

    internal static void DeleteExistingFiles(IEnumerable<string> files)
    {
        foreach (var file in files)
            if (File.Exists(file))
                File.Delete(file);
    }

    internal static string GetNonConflictingDestinationFilePath(string sourceFilePath, string destFilePath)
    {
        var count = 1;
        while (File.Exists(destFilePath))
        {
            string tempFileName = $"{Path.GetFileNameWithoutExtension(sourceFilePath)}({count++})";
            destFilePath = Path.Combine(Path.GetDirectoryName(destFilePath), path2: tempFileName + Path.GetExtension(sourceFilePath));
        }

        return destFilePath;
    }

    private static async Task ExecuteCopyAsync(string source, string target, Options options, CancellationToken cancellationToken)
    {
        switch (options.RemotePath)
        {
            case RemotePathType.None:
                // Local → Local
                await CopyFileAsync(source, target, cancellationToken);
                break;

            case RemotePathType.Target:
                // Local → Remote
                {
                    await using var sourceStream = File.Open(source, FileMode.Open, FileAccess.Read);
                    await ExecuteWithImpersonation(options, async () =>
                    {
                        await using var targetStream = File.Open(target, FileMode.CreateNew, FileAccess.Write);
                        await sourceStream.CopyToAsync(targetStream, 81920, cancellationToken);
                    });
                    break;
                }

            case RemotePathType.Source:
                {
                    // Remote → Local
                    await using var localTargetStream = File.Open(target, FileMode.CreateNew, FileAccess.Write);

                    await ExecuteWithImpersonation(options, async () =>
                    {
                        await using var remoteSourceStream = File.Open(source, FileMode.Open, FileAccess.Read);
                        await remoteSourceStream.CopyToAsync(localTargetStream, 81920, cancellationToken);
                    });

                    break;
                }

            default:
                throw new NotSupportedException($"RemotePathType {options.RemotePath} not supported.");
        }
    }

    public static async Task ExecuteWithImpersonation(Options options, Func<Task> action)
    {
        if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            throw new PlatformNotSupportedException("Impersonation is only supported on Windows.");

        var (domain, user) = GetDomainAndUsername(options.UserName);
        UserCredentials credentials = new UserCredentials(domain, user, options.Password);

        using SafeAccessTokenHandle userHandle = credentials.LogonUser(LogonType.NewCredentials);
        await WindowsIdentity.RunImpersonated(userHandle, action);
    }
}
