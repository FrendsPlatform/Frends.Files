using Frends.Files.Move.Definitions;
using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.ComponentModel;
using System.Threading;
using System.Threading.Tasks;

namespace Frends.Files.Move;

///<summary>
/// Files task.
/// </summary>
public static class Files
{
    /// <summary>
    /// Move files.
    /// [Documentation](https://tasks.frends.com/tasks/frends-tasks/Frends.Files.Move)
    /// </summary>
    /// <param name="input">Input parameters</param>
    /// <param name="options">Options parameters</param>
    /// <param name="connection">Connection parameters</param>
    /// <param name="cancellationToken">Token to stop task. This is generated by Frends.</param>
    /// <returns>Result object { List&lt;FileItem&gt; }</returns>
    public static async Task<Result> Move([PropertyTab] Input input, [PropertyTab] Connection connection,
        [PropertyTab] Options options,
        CancellationToken cancellationToken)
    {
        try
        {
            var result = await ExecuteMoveAsync(input, connection, options, cancellationToken);
            return new Result
            {
                Success = true,
                Files = result
            };
        }
        catch (Exception e) when (e is not OperationCanceledException)
        {
            return ErrorHandler.Handle(e, options.ThrowErrorOnFailure, options.ErrorMessageOnFailure);
        }
    }


    private static async Task<List<FileItem>> ExecuteMoveAsync(Input input, Connection connection, Options options,
        CancellationToken cancellationToken)
    {
        var results =
            ImpersonatedAction.Execute(() => Helpers.FindMatchingFiles(input.SourceDirectory, input.Pattern),
                connection, ImpersonatedPart.Source);
        var fileTransferEntries = Helpers.GetFileTransferEntries(results.Files, input.SourceDirectory,
            input.TargetDirectory, options.PreserveDirectoryStructure);
        if (options.IfTargetFileExists == FileExistsAction.Throw)
            ImpersonatedAction.Execute(() => Helpers.AssertNoTargetFileConflicts(fileTransferEntries.Values.ToArray()),
                connection, ImpersonatedPart.Target);
        if (options.CreateTargetDirectories)
            ImpersonatedAction.Execute(
                () => Directory.CreateDirectory(input.TargetDirectory),
                connection, ImpersonatedPart.Target);
        var fileResults = new List<FileItem>();
        try
        {
            foreach (var (sourceFilePath, targetFilePath) in fileTransferEntries)
            {
                cancellationToken.ThrowIfCancellationRequested();

                if (options.CreateTargetDirectories)
                    ImpersonatedAction.Execute(
                        () => Directory.CreateDirectory(Path.GetDirectoryName(targetFilePath) ?? string.Empty),
                        connection, ImpersonatedPart.Target);

                var hasAccessToValidFile = ImpersonatedAction.Execute(() => File.Exists(targetFilePath), connection,
                    ImpersonatedPart.Target);

                switch (options.IfTargetFileExists)
                {
                    case FileExistsAction.Rename:
                        var validName = ImpersonatedAction.Execute(
                            () => Helpers.GetNonConflictingTargetFilePath(sourceFilePath, targetFilePath),
                            connection, ImpersonatedPart.Target);
                        await Helpers.CopyFileImpersonated(sourceFilePath, validName, connection,
                            cancellationToken);
                        break;

                    case FileExistsAction.Overwrite:
                        if (hasAccessToValidFile)
                            ImpersonatedAction.Execute(() => File.Delete(targetFilePath),
                                connection, ImpersonatedPart.Target);

                        await Helpers
                            .CopyFileImpersonated(sourceFilePath, targetFilePath, connection, cancellationToken)
                            .ConfigureAwait(false);
                        break;

                    case FileExistsAction.Throw:
                        if (hasAccessToValidFile)
                            throw new IOException($"File '{targetFilePath}' already exists. No files moved.");
                        await Helpers
                            .CopyFileImpersonated(sourceFilePath, targetFilePath, connection, cancellationToken)
                            .ConfigureAwait(false);
                        break;
                    default:
                        throw new Exception("Unknown FileExistsAction");
                }

                fileResults.Add(new FileItem
                {
                    SourcePath = sourceFilePath,
                    TargetPath = targetFilePath
                });
            }
        }
        catch (Exception)
        {
            //Delete the target files that were already moved before a file that exists breaks the move command
            ImpersonatedAction.Execute(
                () => Helpers.DeleteExistingFiles(fileResults.Select(x => x.TargetPath)),
                connection, ImpersonatedPart.Source);
            throw;
        }

        ImpersonatedAction.Execute(
            () => Helpers.DeleteExistingFiles(fileResults.Select(x => x.SourcePath)),
            connection, ImpersonatedPart.Source);
        return fileResults;
    }
}